<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="serviceprovider" xmlns:xlink="http://www.w3.org/1999/xlink">
	<title>Service Providers</title>
	<section xml:id="section_serviceprovider_introduction">
		<title>Introduction</title>
		<para>
			The <code>spring-social-core</code> module includes a <emphasis>Service Provider 'Connect' Framework</emphasis> for managing connections to Software-as-a-Service (SaaS) providers such as Facebook and Twitter.
			This framework allows your application to establish connections between local user accounts and accounts those users have with external service providers.  
			Once a connection is established, it can be be used to obtain a strongly-typed Java binding to the ServiceProvider's API, giving your application the ability to invoke the API on behalf of the user.
		</para>
		<para>
			To illustrate, consider Facebook as an example ServiceProvider.
			Suppose your application, AcmeApp, allows users to share content with their Facebook friends.
			To support this, a connection needs to be established between a user's AcmeApp account and her Facebook account.
			Once established, a FacebookApi instance can be obtained and used to post content to the user's wall.
			Spring Social's 'Connect' framework provides a clean API for managing service provider connections such as this.
		</para>
		<para>
			The <interfacename>ServiceProvider&lt;S&gt;</interfacename> interface defines the central API for managing connections to an external service provider such as Facebook:
			<programlisting language="java"><![CDATA[
public interface ServiceProvider<S> {
    
    String getId();
    
    boolean isConnected(Serializable accountId);
    
    List<ServiceProviderConnection<S>> getConnections(Serializable accountId);

}]]>
			</programlisting>
		</para>
		<para>
			The &lt;S&gt; parameterized type represents the Java binding to the ServiceProvider's API.
			For example, the Facebook ServiceProvider implementation is parameterized as ServiceProvider&lt;FacebookApi&gt;, where FacebookApi is the Java interface that may be used to invoke Facebook's graph API on behalf of a user.
		</para>
		<para>
			Each ServiceProvider is identified by an ID, as returned by the <methodname>getId()</methodname> method.
			This id should be unique across all ServiceProviders registered with your application.
		</para>
		<para>
			A single local user account can have one-to-many connections established with a ServiceProvider,
			where each connection represents a link between the local user's account and an external account the user has on the provider's system.
			<methodname>isConnected()</methodname> checks to see if <emphasis>any</emphasis> connections exist between a user account and the service provider.
			If there are connections, <methodname>getConnections()</methodname> returns them in rank order.
		</para>
		<para>
			Once you have a reference to a ServiceProviderConnection, you can do the following:
			<programlisting language="java"><![CDATA[
public interface ServiceProviderConnection<S> {

    S getServiceApi();

    void disconnect();
	
}]]>
			</programlisting>
		</para>
		<para>
			<methodname>getServiceApi()</methodname> returns a Java binding to the ServiceProvider's API for the external user account associated with the connection.
			The API can be used to access and update user data on the provider's system.
		</para>
		<para>
			<methodname>disconnect()</methodname> may be used to remove the connection with the ServiceProvider, if it is no longer desired.
		</para>
		<para>
			To put this framework into action, consider Twitter as an example ServiceProvider.
			Suppose user 'kdonald' of AcmeApp has three Twitter accounts and has connected with each of them:
			<orderedlist>
				<listitem><para>ServiceProvider#getId() would return 'twitter'.</para></listitem>
				<listitem><para>ServiceProvider#isConnected("kdonald") would return 'true'.</para></listitem>
				<listitem><para>ServiceProvider#getConnections("kdonald") would return a 'connections' List with three elements, one for each Twitter account.</para></listitem>
				<listitem><para>connections.get(0) would return the 'connection' to the first Twitter account, and connection.getServiceApi() would return a TwitterApi that can access and update information about that Twitter account.</para></listitem>
				<listitem><para>connections.get(1) and connections.get(2) would allow AcmeApp to access and update information about the second and third Twitter accounts, respectively.</para></listitem>				
				<listitem><para>connection.disconnect() can be called to remove a connection, at which the linked Twitter account is no longer accessible to the application.</para></listitem>				
			</orderedlist>
		</para>
	</section>
	<section id="service-providers-establishing-connections">
		<title>Establishing Connections</title>
		<para>
			So far we have discussed how existing connections are managed using the ServiceProvider framework, but we have not yet discussed how new connections are established.
			The manner in which connections between local user accounts and external provider accounts are established varies based on the authorization protocol used by the ServiceProvider.
			Some service providers use OAuth, others use Basic Auth, others may use something else.
			Spring Social currently provides native support for OAuth-based service providers, including support for OAuth 1 and OAuth 2.
			This covers the leading social networks, such as Facebook and Twitter, all of which use OAuth to secure their APIs.
			Support for other authorization protocols can be added by extending the framework.
		</para>
		<para>
			Because each authorization protocol is different, protocol-specific details are kept out of the base ServiceProvider interface.
			Sub-interfaces have been defined for each protocol, reflecting a distinct ServiceProvider type.
			In the following sections, we will discuss each type of ServiceProvider supported by the framework.
			Each section will also describe the protocol-specific flow required to establish a new connection.
		</para>
		<section id="service-providers-oauth2">
			<title>OAuth2 Service Providers</title>
			<para>
				OAuth 2 is rapidly becoming a preferred authorization protocol, and is used by major service providers such as Facebook, Github, Gowalla, and 37signals.
				In Spring Social, the OAuth2ServiceProvider interface models a service provider based on the OAuth 2 protocol:
			</para>
			<programlisting language="java"><![CDATA[
public interface OAuth2ServiceProvider<S> extends ServiceProvider<S> {

    OAuth2Operations getOAuthOperations();

    ServiceProviderConnection<S> connect(Serializable accountId, AccessGrant accessGrant);

}]]>
			</programlisting>
			<para>
				<methodname>getOAuthOperations()</methodname> returns an API to use to conduct the authorization flow, or "OAuth Dance", with a service provider.
				The result of this flow is an <classname>AccessGrant</classname> that can be used to establish a connection with a local user account by calling <methodname>connect</methodname>.
				The OAuth2Operations interface is shown below:
			</para>
			<programlisting language="java"><![CDATA[
public interface OAuth2Operations {

    String buildAuthorizeUrl(String redirectUri, String scope);

    AccessGrant exchangeForAccess(String authorizationGrant, String redirectUri);

}]]>
			</programlisting>			
			<para>
				Callers are first expected to call buildAuthorizeUrl(String, String) to construct the URL to redirect the user to for connection authorization.
				Upon user authorization, the authorizationGrant returned by the provider should be exchanged for an AccessGrant.
				The AccessGrant should then used to create a connection.
				This flow is illustrated below:
			</para>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/oauth2_flow.png" format="PNG" align="center" scale="70"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="images/oauth2_flow.png" format="PNG" align="center" scale="0"/>
				</imageobject>
			</mediaobject>
      		<para>
				As you can see, there is a back-and-forth conversation that takes place between the application and the service provider to grant the application access to the provider account.
				This exchange, commonly known as the "OAuth Dance", follows these steps:
			</para>
			<orderedlist>
				<listitem>
					<para>
						The flow starts by the application redirecting the user to the provider's authorization URL.
						Here the provider displays a web page asking the user if he or she wishes to grant the application access to read and update their data.
					</para>
				</listitem>
				<listitem>
					<para>
						The user agrees to grant the application access.
					</para>
				</listitem>
				<listitem>
					<para>
						The service provider redirects the user back to the application (via the redirect URI), passing an authorization code as a parameter.
					</para>
				</listitem>
				<listitem>
					<para>
						The application exchanges the authorization code for an access token.
					</para>
				</listitem>
				<listitem>
					<para>
						The service provider issues an access grant to the application.
						The grant includes an access token and a refresh token.
						One receipt of these tokens, the "OAuth dance" is complete.
					</para>
				</listitem>
				<listitem>
					<para>
						The application uses the AccessGrant to save a connection between the local user account and the external provider account.
						With the connection established, the application can get a reference to the Service API to invoke the provider on behalf of the user.
					</para>
				</listitem>
			</orderedlist>
		</section>
		<section id="service-providers-oauth1">
			<title>OAuth1 Service Providers</title>
			<programlisting language="java"><![CDATA[
public interface OAuth1ServiceProvider<S> extends ServiceProvider<S> {

    OAuth1Operations getOAuthOperations();

    ServiceProviderConnection<S> connect(Serializable accountId, OAuthToken accessToken);

}]]>
			</programlisting>
			<programlisting language="java"><![CDATA[
public interface OAuth1Operations {

    OAuthToken fetchNewRequestToken(String callbackUrl);

    String buildAuthorizeUrl(String requestToken);

    OAuthToken exchangeForAccessToken(AuthorizedRequestToken requestToken);

}]]>
			</programlisting>			
			<para>
				The OAuth 1 flow is illustrated below:
			</para>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/oauth1_flow.png" format="PNG" align="center" scale="70"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="images/oauth1_flow.png" format="PNG" align="center" scale="0"/>
				</imageobject>
			</mediaobject>
			<orderedlist>
				<listitem><para>The flow starts with the consumer asking for a request token. A request token's purpose is to obtain user approval and can only be used to obtain an access token. In OAuth 1.0a, the consumer callback URL is passed to the provider when asking for a request token.</para></listitem>
				<listitem><para>The service provider issues a request token to the consumer.</para></listitem>
				<listitem><para>The consumer redirects the user's browser to the provider's authorization page, passing the request token as a parameter. In OAuth 1.0, the callback URL is also passed as a parameter in this step.</para></listitem>
				<listitem><para>The service provider prompts the user to authorize the consumer application and the user agrees. (Note that this is the only step where the user participates in the flow.)</para></listitem>
				<listitem><para>The service provider redirects the user's browser back to a callback URL on the consumer. In OAuth 1.0a, this redirect includes a verifier code as a parameter. At this point, the request token is authorized.</para></listitem>
				<listitem><para>The consumer exchanges the request token (and the verifier in OAuth 1.0a) for an access token.</para></listitem>
				<listitem><para>The service provider issues an access token to the consumer. The "dance" is complete.</para></listitem>
				<listitem><para>The consumer makes calls against the service API, passing the access token along as evidence of its right to access the provider on behalf of the user.</para></listitem>
			</orderedlist>
		</section>
		<para>
			Generally, application code will not work with these interfaces directly.
			Instead, you'll leverage Spring Social's <classname>ConnectController</classname> (see <xref linkend="connecting"/>) to handle the authorization flow for you.
			You may, however, use the <methodname>getConnections()</methodname> to access the service API for a given connection. This will be covered in more detail in <xref linkend="apis"/>.
		</para>
	</section>


  <section xml:id="section_serviceproviderconfig">
      <title>Configuring Service Providers</title>
      
      <para>Working with the service provider framework starts with configuring the service provider in Spring. Spring Social's configuration namespace provides a convenient <code><![CDATA[<social:service-provider>]]></code> element for declaring a service provider:</para>
      
      <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:social="http://www.springframework.org/schema/spring-social"
    xsi:schemaLocation="http://www.springframework.org/schema/spring-social 
             http://www.springframework.org/schema/social/spring-social-1.0.xsd
        http://www.springframework.org/schema/beans 
             http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

<social:service-provider 
    class="org.springframework.social.twitter.connect.TwitterServiceProvider" 
    client-key="..." 
    client-secret="..." />        
</beans>]]></programlisting>

      <para>The <code>class</code> attribute specifies the fully-qualified name of the provider implementation. This can be any of the service provider implementations that come with Spring Social or a custom implementation. Spring Social comes with the following service provider implementations:</para>

      <itemizedlist>
          <listitem><para>org.springframework.social.facebook.connect.FacebookServiceProvider</para></listitem>
          <listitem><para>org.springframework.social.twitter.connect.TwitterServiceProvider</para></listitem>
          <listitem><para>org.springframework.social.linkedin.connect.LinkedInServiceProvider</para></listitem>
          <listitem><para>org.springframework.social.tripit.connect.TripItServiceProvider</para></listitem>
          <listitem><para>org.springframework.social.github.connect.GitHubServiceProvider</para></listitem>
          <listitem><para>org.springframework.social.gowalla.connect.GowallaServiceProvider</para></listitem>
      </itemizedlist>
      
      <para>The <code>client-key</code> and <code>client-secret</code> attributes specify the key and secret values assigned to your application when you registered it with the provider.</para>

      <section xml:id="section_config_connectionrepository">
          <title>Connection Repository</title>
          
          <para>When a service provider creates a connection, the connection details must be persisted somewhere for future use. The service provider relies on a connection repository for persistence of connection Spring Social comes with <classname>JdbcConnectionRepository</classname>, a connection repository that persists connections to a relational database via JDBC. The following XML shows how to configure a <classname>JdbcConnectionRepository</classname> bean:</para>
          
          <programlisting><![CDATA[<bean id="connectionRepository" class="org.springframework.social.connect.jdbc.JdbcConnectionRepository">
    <constructor-arg ref="dataSource" />
    <constructor-arg ref="textEncryptor" />
</bean>]]></programlisting>

          <para><classname>JdbcConnectionRepository</classname> is constructed with a reference to a <classname>DataSource</classname> through which it will communicate with the database and a <interfacename>TextEncryptor</interfacename> that it will use to encrypt/decrypt sensitive connection details (such as access tokens and secrets).</para>
          
          <para>The <interfacename>TextEncryptor</interfacename> is defined in Spring Security 3.1 in the <code>org.springframework.security.crypto.encrypt</code> package. Spring Security 3.1 also includes an <classname>Encryptors</classname> class which acts as a factory for common encryptor implementations. For example, to configure a no-op text encryptor (one that doesn't perform any encryption at all):</para>

          <programlisting><![CDATA[<bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" factory-method="noOpText" />]]></programlisting>
          
          <para>Or, to configure a text encryptor that uses standard password-based encryption:</para>
          
          <programlisting><![CDATA[<bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" factory-method="text">
    <constructor-arg value="password"/>
    <constructor-arg value="salt"/>    
</bean>]]></programlisting>

          <para>Note that the ID of the connection repository bean is significant. By default, the <code><![CDATA[<social:service-provider>]]></code> element will assume that the connection repository bean's ID is "connectionRepository". If, however, you give the connection repository bean a different ID, then you'll need to explicitly specify the connection repository when configuring a <code><![CDATA[<social:service-provider>]]></code>:</para>

          <programlisting><![CDATA[<social:service-provider 
              class="org.springframework.social.twitter.connect.TwitterServiceProvider" 
              client-key="..." 
              client-secret="..."
              connection-repository="connectionStorage" />]]></programlisting>
              
              
          <para><code>JdbcConnectionRepository</code> assumes that a <code>Connection</code> table exists and was created as follows:</para>
          
<programlisting><![CDATA[create table Connection (id identity,
			accountId varchar not null,
			providerId varchar not null,
			accessToken varchar not null,					
			secret varchar, 
			refreshToken varchar,
			primary key (id));
create unique index AccessToken on Connection(accountId, providerId, accessToken);]]></programlisting>

          <para>For convenience sake, SQL is available in Spring Social's core module as a resource: /org/springframework/social/connect/jdbc/ConnectionRepositorySchema.sql.</para>
      </section>
  </section>

  <section xml:id="section_newserviceprovider">
      <title>Extending Spring Social with custom service providers</title>
      
      <para>Even though Spring Social only comes with a handful of service provider implementations, you can easily extend Spring Social's reach into other services by creating a custom service provider implementation.</para>
      
      <para>The first step in creating a new service provider implementation is to determine what kind of authorization the service requires. Spring Social provides abstract service provider classes for both OAuth 1 and OAuth 2-based services in <classname>AbstractOAuth1ServiceProvider</classname> and <classname>AbstractOAuth1ServiceProvider</classname>, respectively. If your service uses some authorization mechanism other than OAuth, you may choose to base your service provider on <classname>AbstractServiceProvider</classname> instead.</para>
      
      <para>To understand how this works, have a look at how some of the existing service provider implementations have been created. For example, consider <classname>TwitterServiceProvider</classname> as an example of how to develop an OAuth 1-based service provider:</para>
      
      <programlisting><![CDATA[package org.springframework.social.twitter.connect;

import org.springframework.social.connect.oauth1.AbstractOAuth1ServiceProvider;
import org.springframework.social.connect.support.ConnectionRepository;
import org.springframework.social.oauth1.OAuth1Template;
import org.springframework.social.twitter.TwitterOperations;
import org.springframework.social.twitter.TwitterTemplate;

public final class TwitterServiceProvider extends AbstractOAuth1ServiceProvider<TwitterOperations> {

	public TwitterServiceProvider(String consumerKey, String consumerSecret, ConnectionRepository connectionRepository) {
		super("twitter", connectionRepository, consumerKey, consumerSecret, 
		    new OAuth1Template(consumerKey, consumerSecret, 
		        "https://twitter.com/oauth/request_token",
				"https://twitter.com/oauth/authorize?oauth_token={requestToken}", 
				"https://twitter.com/oauth/access_token"));
	}

	@Override
	protected TwitterOperations getApi(String consumerKey, String consumerSecret, String accessToken, String secret) {
		return new TwitterTemplate(consumerKey, consumerSecret, accessToken, secret);
	}

}]]></programlisting>
      
      <para>The first thing to note is that <classname>TwitterServiceProvider</classname> extends <classname>AbstractOAuth1ServiceProvider</classname>, parameterized with <interfacename>TwitterOperations</interfacename>. This indicates that <classname>TwitterServiceProvider</classname> is an OAuth 1-based provider and that its service API is a <interfacename>TwitterOperations</interfacename>.</para>
      
      <para><classname>TwitterServiceProvider</classname>'s constructor is given the provider's consumer key and secret along with a connection repository for persisting connection details. It calls the super constructor, passing the provider's ID, the connection repository, the consumer key and secret, and an instance of <classname>OAuth1Template</classname> that will be used to perform the authorization calls to Twitter.</para>
      
      <para>The <classname>OAuth1Template</classname> itself is constructed with the consumer key and secret, along with Twitter's request token URL, authorization URL, and access token URL. Note that the authorization URL is parameterized and must have a "requestToken" placeholder.</para>
      
      <para>In addition to the constructor, a subclass of <classname>AbstractOAuth1ServiceProvider</classname> must also override the <methodname>getApi()</methodname>. This method's job is to return an instance of the service API. In this case, it uses the consumer key and secret and the access token and secret to instantiate a <classname>TwitterTemplate</classname>.</para>
      
      <para>If you have a look at some of the other OAuth 1-based service providers in Spring Social, you'll see that they aren't much different than this one, aside from their ID, their OAuth 1 URLs, and their service API.</para>
      
      <para>Speaking of the service API, that's the one other thing you'll need to write in order to create a new service provider. In the case of <classname>TwitterServiceProvider</classname>, the service API is defined by the <interfacename>TwitterOperations</interfacename> interface and <classname>TwitterTemplate</classname> implementation of that interface.</para>
      
      <para>An OAuth 2 service provider implementation is only slightly different than an OAuth 1 service provider, as you can see by looking at <classname>FacebookServiceProvider</classname>:</para>
      
      <programlisting><![CDATA[package org.springframework.social.facebook.connect;

import org.springframework.social.connect.oauth2.AbstractOAuth2ServiceProvider;
import org.springframework.social.connect.support.ConnectionRepository;
import org.springframework.social.facebook.FacebookOperations;
import org.springframework.social.facebook.FacebookTemplate;
import org.springframework.social.oauth2.OAuth2Template;

public final class FacebookServiceProvider extends AbstractOAuth2ServiceProvider<FacebookOperations> {

	public FacebookServiceProvider(String clientId, String clientSecret, ConnectionRepository connectionRepository) {
		super("facebook",connectionRepository, 
		    new OAuth2Template(clientId, clientSecret,
			    "https://graph.facebook.com/oauth/authorize?client_id={client_id}&redirect_uri={redirect_uri}&scope={scope}", 
                "https://graph.facebook.com/oauth/access_token"));
	}

	@Override
	protected FacebookOperations getApi(String accessToken) {
		return new FacebookTemplate(accessToken);
	}

}]]></programlisting>
      
      <para>The key difference is that <classname>FacebookServiceProvider</classname> extends <classname>AbstractOAuth2ServiceProvider</classname> instead of <classname>AbstractOAuth1ServiceProvider</classname>. Its constructor is given the client ID and client secret (the OAuth 2 equivalent of consumer key and consumer secret) and the connection repository. It uses them to call the super constructor with the provider ID, the connection repository, and an instance of <classname>OAuth2Template</classname> to conduct the OAuth 2 exchange with Facebook.</para>
      
      <para>The <classname>OAuth2Template</classname> is constructed much like <classname>OAuth1Template</classname> except that it doesn't need a request token URL. Also, the authorization URL is parameterized with "client_id", "redirect_uri", and "scope".</para>
      
      <para>Finally, the <methodname>getApi()</methodname> is given only the access token needed to construct <classname>FacebookTemplate</classname>.</para>
      
      <para>Again, if you compare <classname>FacebookServiceProvider</classname> with some of the other OAuth 2 service provider implementations (e.g., <classname>GitHubServiceProvider</classname> and <classname>GowallaServiceProvider</classname>), you'll see that they're all quite similar with the key difference being their IDs, service APIs, and OAuth 2 URLs.</para>
  </section>
</chapter>
