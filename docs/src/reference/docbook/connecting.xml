<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="connecting"
    xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Connecting to Social Providers</title>

  <para>Most social connections are based on OAuth authorization. Authorizing an application to access a social provider on behalf of a user involves a back-and-forth conversation between the application, the social network, and the user. This conversation, commonly referred to as the "OAuth Dance", involves the application asking the user to tell the social network that it's okay for the application to access and manipulate their social information. The outcome of the dance is an access token that the application can use as a sort of valet key to interact with the social network on the user's behalf.</para>
  
  <section id="connect-controller">
    <title>Creating connections with <classname>ConnectController</classname></title>

    <para>To simplify an application's role in the OAuth dance, Spring Social provides <classname>ConnectController</classname>. <classname>ConnectController</classname> is a Spring MVC controller that handles the application's part in the OAuth dance.</para>

    <para>To use <classname>ConnectController</classname>, configure it along with other controllers in your application's Spring MVC configuration:</para>

    <programlisting><![CDATA[
<bean class="org.springframework.social.web.connect.ConnectController">
	<constructor-arg ref="serviceProviderFactory" />
	<constructor-arg ref="accountIdResolver" />
	<constructor-arg value="http://localhost:8080/myapplication" />
</bean>
]]></programlisting>


    <para><classname>ConnectController</classname> is constructed with three arguments:</para>
    
    <itemizedlist>
        <listitem><para>A reference to an instance of a <interfacename>ServiceProviderFactory</interfacename> to assist <classname>ConnectController</classname> in obtaining service providers.</para></listitem>
        <listitem><para>A reference to an instance of an <interfacename>AccountIdResolver</interfacename> so that <classname>ConnectController</classname> will know which application account to create connections for.</para></listitem>
        <listitem><para>The base URL for the application. <classname>ConnectController</classname> will use this to construct callback URLs used in the OAuth dance.</para></listitem>
    </itemizedlist>

    <para><classname>ConnectController</classname> can handle the application's side of the OAuth dance for either OAuth 1 or OAuth 2 providers. For OAuth 1 providers, <classname>ConnectController</classname> supports the following flow:</para>
    
    <itemizedlist>
        <listitem><para><code>GET /connect/{provider}</code> - Displays a web page showing connection status to the provider.</para></listitem>
        <listitem><para><code>POST /connect/{provider}</code> - Initiates the connection flow with the provider.</para></listitem>
        <listitem><para><code>GET /connect/{provider}?oauth_token={request token}</code> - Receives the authorization callback from the provider, accepting a request token. Uses the request token to request an access token and complete the connection.</para></listitem>
        <listitem><para><code>DELETE /connect/{provider}</code> - Severs a connection with the provider.</para></listitem>
    </itemizedlist>

    <para>For an OAuth 2 provider, the flow is almost identical, with a subtle difference in how the authorization callback is handled:</para>
    
    <itemizedlist>
        <listitem><para><code>GET /connect/{provider}?code={code}</code> - Receives the authorization callback from the provider, accepting an authorization code. Uses the code to request an access token and complete the connection.</para></listitem>
    </itemizedlist>
    
    <para><classname>ConnectController</classname> also supports a registration-then-connect flow, which is covered in <xref linkend="registration-flow"/>.</para>

    <section id="connect-controller-flow-1">
      <title>Displaying a connection page</title>

      <para>Before the connection flow starts in earnest, a web application may choose to show a page that offers the user information on their connection status and offer them the opportunity to create a connection between their account and their social profile. <classname>ConnectController</classname> can display such a page if the browser navigates to <code>/connect/{provider}</code>.</para>
      
      <para>For example, to display a connection status page for Twitter, where the provider name is "twitter", your application should provide a link similar to this:</para>
    
        <programlisting><![CDATA[
<a href="<c:url value="/connect/twitter" />">Connect to Twitter</a>
]]></programlisting>

        <para><classname>ConnectController</classname> will respond to this request by first checking to see if a connection already exists between the user's account and Twitter. If not, then it will with a view that should offer the user an opportunity to create the connection. Otherwise, it will respond with a view to inform the user that a connection already exists.</para>
    
        <para>The view names that <classname>ConnectController</classname> responds with are based on the provider's name. In this case, since the provider name is "twitter", the view names are "connect/twitterConnect" and "connect/twitterConnected".</para>
        
        <note>
            <para>Although the view names are derived from the provider name, it may be possible to specify these view names in a future version of Spring Social. Follow <ulink url="https://jira.springframework.org/browse/SOCIAL-91" /> for more details.</para>
        </note>
            
        
    </section>
    
    <section id="connect-controller-flow-2">
      <title>Initiating the connection flow</title>
      
      <para>To kick off the connection flow, the application should <code>POST</code> to <code>/connect/{provider}</code>. Continuing with the Twitter example, the JSP resolved from "connect/twitterConnect" might include the following form:</para>
      
      <programlisting><![CDATA[<form action="<c:url value="/connect/twitter" />" method="POST">
    <p>You haven't created any connections with Twitter yet. Click the button to create
       a connection between your account and your Twitter profile. 
       (You'll be redirected to Twitter where you'll be asked to authorize the connection.)</p>
    <p><button type="submit"><img src="<c:url value="/resources/social/twitter/signin.png" />"/></button></p>
</form>]]></programlisting>
      
      <para>When <classname>ConnectController</classname> handles the request, it will redirect the browser to the provider's authorization page. In the case of an OAuth 1 provider, it will first fetch a request token from the provider and pass it along as a parameter to the authorization page. Request tokens aren't used in OAuth 2, however, so instead it passes the application's client ID and redirect URI as parameters to the authorization page.</para>
      
      <para>For example, Twitter's authorization URL has the following pattern:</para>
      
      <programlisting><![CDATA[https://twitter.com/oauth/authorize?oauth_token={token}]]></programlisting>
      
      <para>If the application's request token were "vPyVSe"<footnote><para>This is just an example. Actual request tokens are typically much longer.</para></footnote>, then the browser would be redirected to https://twitter.com/oauth/authorize?oauth_token=vPyVSe and a page similar to the following would be displayed to the user (from Twitter)<footnote><para>If the user has not yet signed into Twitter, the authorization page will also include a username and password field for authentication into Twitter.</para></footnote>:</para>
      
      <mediaobject>
        <imageobject role="fo">
            <imagedata fileref="images/twitter-authorize.png"
              format="PNG" align="center" scale="40"/>
        </imageobject>
        <imageobject role="html">
            <imagedata fileref="images/twitter-authorize.png" format="PNG" align="center" scale="40"/>
        </imageobject>
      </mediaobject>
      
      <para>In contrast, Facebook is an OAuth 2 provider, so its authorization URL takes a slightly different pattern:</para>
      
      <programlisting><![CDATA[https://graph.facebook.com/oauth/authorize?client_id={clientId}&redirect_uri={redirectUri}]]></programlisting>
      
      <para>Thus, if the application's Facebook client ID is "0b754" and it's redirect URI is "http://www.mycoolapp.com/connect/facebook", then the browser would be redirected to <![CDATA[https://graph.facebook.com/oauth/authorize?client_id=0b754&redirect_uri=http://www.mycoolapp.com/connect/facebook]]> and Facebook would display the following authorization page to the user:</para>
      
      <mediaobject>
        <imageobject role="fo">
            <imagedata fileref="images/facebook-authorize-basic.png"
              format="PNG" align="center" scale="40"/>
        </imageobject>
        <imageobject role="html">
            <imagedata fileref="images/facebook-authorize-basic.png" format="PNG" align="center" scale="40"/>
        </imageobject>
      </mediaobject>      

      <!-- TODO: Grab screen shot of simple authorization with Facebook then use existing screenshot to discuss scope attribute -->
      
      <para>If the user clicks the "Allow" button to authorize access, the provider will redirect the browser back to the authorization callback URL where <classname>ConnectController</classname> will be waiting to complete the connection.</para>
      
      <para>The behavior varies from provider to provider when the user denies the authorization. For instance, Twitter will simply show a page telling the user that they denied the application access and does not redirect back to the application's callback URL. Facebook, on the other hand, will redirect back to the callback URL with error information as request parameters.</para>
      
      <section id="connect-controller-flow-3-scope">
        <title>Authorization scope</title>

        <para>In the previous example of authorizing an application to interact with a user's Facebook profile, you notice that the application is only requesting access to the user's basic profile information. But there's much more that an application can do on behalf of a user with Facebook than simply harvest their profile data. For example, how can an application gain authorization to post to a user's Facebook wall?</para>
        
        <para>OAuth 2 authorization may optionally include a scope parameter that indicates the type of authorization being requested. On the provider, the "scope" parameter should be passed along on the authorization URL. In the case of Facebook, that means that the Facebook authorization URL pattern should be as follows:</para>
        
<programlisting><![CDATA[https://graph.facebook.com/oauth/authorize?client_id={clientId}&redirect_uri={redirectUri}&scope={scope}]]></programlisting>

        <para><classname>ConnectController</classname> accepts a "scope" parameter at authorization and passes its value along to the provider's authorization URL. For example, to request permission to post to a user's Facebook wall, the connect form might look like this:</para>

              <programlisting><![CDATA[<form action="<c:url value="/connect/twitter" />" method="POST">
    <input type="hidden" name="scope" value="publish_stream,offline_access" />
    <p>You haven't created any connections with Twitter yet. Click the button to create
       a connection between your account and your Twitter profile. 
       (You'll be redirected to Twitter where you'll be asked to authorize the connection.)</p>
    <p><button type="submit"><img src="<c:url value="/resources/social/twitter/signin.png" />"/></button></p>
</form>]]></programlisting>
              
        <para>The hidden "scope" field contains the scope values to be passed along to Facebook's authorization URL. In this case, "publish_stream" requests permission to post to a user's wall. In addition, "offline_access" requests permission to access Facebook on behalf of a user even when the user isn't using the application.</para>
        
        <note>
            <para>OAuth 2 access tokens typically expire after some period of time. Per the OAuth 2 specification, an application may continue accessing a provider after a token expires by using a refresh token to either renew an expired access token or receive a new access token (all without troubling the user to re-authorize the application).</para>
            
            <para>Facebook does not currently support refresh tokens. Moreover, Facebook access tokens expire after about 2 hours. So, to avoid having to ask your users to re-authorize ever 2 hours, the best way to keep a long-lived access token is to request "offline_access".</para>
        </note>

        <para>When asking for "publish_stream,offline_access" authorization, the user will be prompted with the following authorization page from Facebook:</para>

        <mediaobject>
          <imageobject role="fo">
              <imagedata fileref="images/facebook-authorize-scoped.png"
                format="PNG" align="center" scale="40"/>
          </imageobject>
          <imageobject role="html">
              <imagedata fileref="images/facebook-authorize-scoped.png" format="PNG" align="center" scale="40"/>
          </imageobject>
        </mediaobject>
        
        <para>Scope values are provider-specific, so check with the service provider's documentation for the available scopes. Facebook scopes are documented at <ulink url="http://developers.facebook.com/docs/authentication/permissions" />.</para>
        
      </section>
    </section>
    
    <section id="connect-controller-flow-3">
      <title>Responding to the authorization callback</title>
      
      <para>After the user agrees to allow the application have access to their profile on the provider, the provider will redirect their browser back to the application's authorization URL with a code that can be exchanged for an access token. For OAuth 1.0a providers, the callback URL is expected to receive the code (known as a verifier in OAuth 1 terms) in a <code>verifier</code> parameter. For OAuth 2, the code will be in a <code>code</code> parameter.</para>
      
      <para><classname>ConnectController</classname> will handle the callback request and trade in the verifier/code for an access token. Once the access token has been received, the OAuth dance is complete and the application may use the access token to interact with the provider on behalf of the user. The last thing that <classname>ConnectController</classname> does is to hand off the access token to the <interfacename>ServiceProvider</interfacename> implementation to be stored for future user.</para>
    </section>

    <section id="connect-controller-flow-disconnect">
      <title>Disconnecting</title>
      
      <para>To delete a connection via <classname>ConnectController</classname>, submit a DELETE request to "/connect/{provider}".</para>
      
      <para>In order to support this through a form in a web browser, you'll need to have Spring's <ulink url="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/filter/HiddenHttpMethodFilter.html"><classname>HiddenHttpMethodFilter</classname></ulink> configured in your application's web.xml. Then you can provide a disconnect button via a form like this:</para>
      
      
        <programlisting><![CDATA[<form action="<c:url value="/connect/twitter" />" method="post">
   <div class="formInfo">
      <p>Spring Social Showcase is connected to your Twitter account.
         Click the button if you wish to disconnect.</p>
   </div>
   <button type="submit">Disconnect</button>	
   <input type="hidden" name="_method" value="delete" />
</form>]]></programlisting>
      
      
      <para>When this form is submitted, <classname>ConnectController</classname> will call the <methodname>disconnect()</methodname> method on the <interfacename>ServiceProvider</interfacename> implementation to remove the connection.</para>
    </section>
  </section>

  <section id="registration-flow">
      <title>Registering users with social profile data</title>
      
      <para>A convenient feature of many social-ready applications is the ability for a new user to register with the application, creating their new account with data extracted from one of their social network profiles. It's convenient to the user, as they won't have to enter all of their information and can be assured that the data is consistent. It's also convenient for the social application, as it can trust that some of the data has already been vetted by the social provider (such as confirming email addresses).</para>
      
      <para>In the connection flow described in <xref linkend="connect-controller"/>, <classname>ConnectController</classname> assumes that the user already has created an account with the application and simply wants to connect that account to one of their social network profiles. But <classname>ConnectController</classname> also supports a register-then-connect flow that enables a new user to create a new account using social profile data and then connect that account as part of the registration process.</para>
      
      <para>The register-then-connect flow is quite similar to the connect flow, but with a few small differences.</para>
      
      <orderedlist>
          <listitem><para><code>GET /connect/{provider}/register</code> - Displays a web page showing connection status to the provider.</para></listitem>
          <listitem><para><code>POST /connect/{provider}</code> - Initiates the register-then-connect flow.</para></listitem>
          <listitem><para><code>GET /connect/{provider}?oauth_token={token}</code> or <code>GET /connect/{provider}?code={code}</code>- Receives the authorization callback from the provider, accepting a request token or code. After requesting an access token, the user will be redirected to a registration form with an object containing the user profile data in the request.</para></listitem>
          <listitem><para><code>GET /connect/{provider}/register</code> - The application should redirect to this URL after a successful registration to resume the flow and complete the connection.</para></listitem>
          <listitem><para><code>DELETE /connect/{provider}</code> - Severs a connection with the provider.</para></listitem>
      </orderedlist>
      
      <para>Unlike the connect flow where step 3 both retrieves an access token from the provider and establishes the connection, step 3 in the register-then-connect flow only retrieves the access token. It cannot create the connection since the user has not yet registered and there is no account to connect with.</para>
      
      <para>Once <classname>ConnectController</classname> has an access token, it stores it away (in the session) and sends the user to a registration form. The view name of the registration form is derived from the provider name. If the provider name is "github", then the registration view name will be "connect/githubRegister".</para>
      
      <para>Before going to the registration view, however, <classname>ConnectController</classname> retrieves a user profile object from the provider and places it into the request as an attribute named "{provider}UserProfile". If the provider's name is "github", then the attribute name is "githubUserProfile". This object can be used to prepopulate the application's registration form with data from the user's social profile. The type of the profile object will vary from provider to provider and is determined by the object returned from the provider implementation's <methodname>getProviderUserProfile()</methodname> method.</para>
      
      <para>The application is expected to provider a controller to handler submission of the registration form and, after successful registration, redirect the browser to <classname>ConnectController</classname>'s via the "/connect/{provider}/register" URL.</para>
      
      <para>For example, the GitHub showcase sample has a Spring MVC controller with the following handler method to process registration form submission:</para>
      
      
        <programlisting><![CDATA[@RequestMapping(value = "/signup", method = RequestMethod.POST)
   public String register(ShowcaseUser user) {
   
      // ... create a new account
   
      return "redirect:/connect/github/register";
   }]]></programlisting>
      
      <para>After the account has been created, the controller redirects to "/connect/github/register", which is handled by <classname>ConnectController</classname>. <classname>ConnectController</classname> will then pull the access token from the session and use it to complete the connection between the newly created account and the user's social profile.</para>
  </section>

  <section id="connect-interceptors">
    <title>Connection interceptors</title>

    <para>In the course of creating a connection with a service provider, you may want to interject additional functionality into the OAuth flow. For instance, perhaps you'd like to automatically post a tweet to a user's Twitter timeline immediately upon creating the connection.</para>
    
    <para><classname>ConnectController</classname> may be configured with one or more connection interceptors that it will call at points in the OAuth flow. These interceptors are defined by the <interfacename>ConnectInterceptor</interfacename> interface:</para>
    
    <programlisting><![CDATA[public interface ConnectInterceptor<S> {
   void preConnect(ServiceProvider<S> provider, WebRequest request);
   void postConnect(ServiceProvider<S> provider, WebRequest request);
}]]></programlisting>

    <para>The <methodname>preConnect()</methodname> method will be called by <classname>ConnectController</classname> just before redirecting the browser to the provider's authorization page. <methodname>postConnect()</methodname> will be called immediately after a connection has been established between the member account and the provider profile.</para>
    
    <para>For example, suppose that after a connection is made, you want to immediately tweet that connection to the user's Twitter timeline. To accomplish that, you might write the following connection interceptor:</para>
    
    <programlisting><![CDATA[package org.springframework.social.samples.twitter;
import org.springframework.social.provider.ServiceProvider;
import org.springframework.social.web.connect.ConnectInterceptor;
import org.springframework.social.twitter.TwitterOperations;
import org.springframework.web.context.request.WebRequest;

public class TwitterConnectInterceptor implements ConnectInterceptor<TwitterOperations> {
	public void preConnect(ServiceProvider<TwitterOperations> provider, WebRequest request) {
		// nothing to do
	}

	public void postConnect(ServiceProvider<TwitterOperations> provider, WebRequest request) {
		provider.getServiceOperations(getAccountId()).updateStatus("I just connected with the Spring Social Showcase!");
	}

	private Long getAccountId() {
		// ...
	}
}]]></programlisting>

    <para>Then wire this interceptor into <classname>ConnectController</classname>:</para>
    
        <programlisting><![CDATA[
    <bean class="org.springframework.social.web.connect.ConnectController">
    	<constructor-arg ref="serviceProviderFactory" />
    	<constructor-arg value="http://localhost:8080/myapplication" />
    	<constructor-arg ref="accountIdResolver" />
    	<property name="interceptors">
    	    <list>
    	        <bean class="org.springframework.social.samples.twitter.TwitterConnectInterceptor" />
	        </list>
	    </property>
    </bean>
    ]]></programlisting>
    
    <para>Note that the <code>interceptors</code> property is a list and can take as many interceptors as you'd like to wire into it. When it comes time for <classname>ConnectController</classname> to call into the interceptors, it will only invoke the interceptor methods for those interceptors accept service operations type matching the service provider's operations type. In the example given here, only connections made through a service provider whose operation type is <interfacename>TwitterOperations</interfacename> will trigger the interceptor's methods.</para>
  </section>
  
  <section id="facebook-connect-controller">
    <title><classname>FacebookConnectController</classname></title>

    <para>In addition to the OAuth 2 web server profile, Facebook also offers connectivity via JavaScript and the Facebook markup language. Spring Social supports this kind of Facebook connectivity with <classname>FacebookConnectController</classname>.</para>
    
    <programlisting><![CDATA[<%@ page session="false" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ taglib uri="http://www.springframework.org/tags" prefix="s" %>
<%@ taglib uri="http://www.springframework.org/spring-social/facebook/tags" prefix="facebook" %>
<html>
    <head>
    	<title>Facebook Showcase: Connect to Facebook</title>
    	<script type="text/javascript" src="<c:url value="/resources/jquery/1.4/jquery.js" />"></script>	
    	<script>
    		function signInWithFacebook() {
    			FB.getLoginStatus(function(response) {
    		        if (response.session) {
    		    		$('#fb_signin').submit();
    		        }
    		      });

    		}
    	</script>
    </head>
    <body>
        <h1>Facebook Showcase: Connect to Facebook</h1>

        <form id="fb_signin" action="<c:url value="/connect/facebook" />" method="post">
    	    <div class="formInfo">
    		    <p>Click the button to connect Facebook Showcase with your Facebook account.</p>
    	    </div>
    	    <div id="fb-root"></div>	
    	    <p><fb:login-button perms="email,publish_stream,offline_access" 
    	       onlogin="signInWithFacebook();" v="2" length="long">Connect to Facebook</fb:login-button></p>
        </form>
        
        <facebook:init />
    </body>
</html>]]></programlisting>
    
    
    <para>When the user clicks on the "Connect to Facebook" button, they will be presented with the following authorization dialog<footnote><para>If the user hasn't yet signed in to Facebook, they will first be prompted with a signin page by Facebook.</para></footnote>:</para>
    
    <mediaobject>
      <imageobject role="fo">
          <imagedata fileref="images/facebook-authorize-loginbutton.png"
            format="PNG" align="center" scale="40"/>
      </imageobject>
      <imageobject role="html">
          <imagedata fileref="images/facebook-authorize-loginbutton.png" format="PNG" align="center" scale="40"/>
      </imageobject>
    </mediaobject>
    
    
    
    <para>When the user clicks on the "Allow" button, the dialog will close and the access token will be written to a cookie. If the user clicks on the "Don't Allow" button, the dialog will still close, but no cookie will be written.</para>
    
    <para>TODO: Finish this section</para>
    
    <programlisting><![CDATA[<bean class="org.springframework.social.facebook.connect.FacebookConnectController">
        <constructor-arg ref="facebookProvider" />
        <constructor-arg ref="accountIdResolver" />
</bean>]]></programlisting>

  </section>
</chapter>
